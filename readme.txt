# css343lab4

1. Describe the state of your program, exactly what works and what does not work.
	The program works exactly as expected by the assignment specification. We have a generic NodeData class that is the parent class of Item, which is the parent class of Book, which is the parent class of ChildrensBook, Fiction, and Periodical, which are genres of books that the library contains. The idea of having parent classes NodeData and Item of Book allows the library to be extensible to hold different types of Items (such as movies, audiobooks, etc.). The factory design pattern furthers this idea of extensibility. We have an ItemFactory that allow different types of items to be added as classes as long as they implement all of the pure virtual methods in Item. We also have different types of actions (checkout, displayhistory, displaylibrary, and return) that are child classes of PatronAction. We also have an ActionFactory that allows different types of actions to be added to the library later. Overall, the state of the program is that the lab works exactly as expected. 

2. List your hash table(s) that you wrote (not STL) - briefly what they are used for and file they are found in. (Include any factories that are essentially hash tables)
	We wrote one hash table which holds pointers to Patron objects. This hash table class is found in hashtable.h and the implementation is in hashtable.cpp. This hash table is implemented using array of size 10000. This is because the minimum patronId is 0000 and the maximum patronId is 9999. Hence, we have a hash function that simply returns the patronId as the index that the patron will be located at. The get() and add() functions hence have constant runtimes. The ActionFactory also contains basically a hash table. This hash table is of size 26 (MAX_COMMAND_TYPES), which indicates the maximum number of actions possible (as many letters as there are in the alphabet). The hash function returns the integer representation of the character passed into it. We constructed the ActionFactory by placing the actions from the assignment spec at their appropriate locations. The ItemFactory also contains basically a hash table. This hash table is of size 26 (MAX_ITEM_TYPES), which indicates the maximum number of item types possible (as many letters as there are in the alphabet). The hash function returns the integer representation of the character passed into it. We constructed the ItemFactory by placing the items from the assignment spec at their appropriate locations.

3. State which file and which function you read the book data, just high-level function calls, i.e., how/where it gets into your collections.
	We read the book data, patron data, and command data in the library.cpp file. For the book data, we have a function called buildLibrary(ifstream&) which loops through the book data line by line. For each line, we created an Item* using the library item factory and passing in the character at the beginning of the line on each line of book data. We then called the setData(infile) method that each item has implemented, and that sets the data fields of that item by reading the rest of the line of data. We then insert this into the binary tree of it's respective item type by calling itemTypes[itemType - 'A'].insert(itemPtr). 

4. State which file and which function you read the command data, high-level function calls, how/where you perform the commands.
	The performCommands function in the library.cpp file functions in a similar way to the buildLibrary function. The performCommands function parses the commands file line by line and uses the ActionFactory to create an action by reading in the first letter in each line and calling actionFactory.createIt(actionType, infile). It then calls action->setData(this, infile), which passes in the library and the file to the actions setData method. This setData method parses the rest of the line and sets the PatronAction class's data fields using the line on the data. setData also prints out errors in case any of the data on the line is invalid. We then check if the setData was successful as it has a bool return value. If it returns true, we call action->perform() which performs the action on the library. If it returns false, then perform is not called, and an error is printed to the console. 

5. Describe any dirty little secrets (e.g., switch used, or if-else-if, etc.)  If you feel they do not violate the open-closed design principle, explain.
	We don't have any dirty little secrets that violate the open-closed design principle. We worked very hard to make sure that the program does not violate this principle. This is why we used the ItemFactory and ActionFactory to create Item and PatronAction objects and setData on them, as well as perform the commands for the PatronAction objects. 

6. Describe anything you are particularly proud of.
	We are very proud of how the project worked very well. We also are very proud of how we followed all of the implementation notes. We feel that we did a great job not violating the open-closed design principle and got the program to work with minimal switches. Overall, we had a fun time completing this lab. We really enjoyed the OOP aspect of the project, as well as the fact that we had a lot of say in how to design it. 